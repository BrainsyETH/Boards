-- FloatMissouri River Data Schema for Supabase/PostGIS
-- Generated by scrape_floatmissouri.py

-- Enable PostGIS extension if not already enabled
CREATE EXTENSION IF NOT EXISTS postgis;

-- Rivers table
CREATE TABLE IF NOT EXISTS rivers (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    url TEXT,
    difficulty TEXT,
    gradient_general NUMERIC(4,2),
    gradient_details TEXT,
    counties TEXT[],
    description TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Mile markers table
CREATE TABLE IF NOT EXISTS mile_markers (
    id SERIAL PRIMARY KEY,
    river_id TEXT NOT NULL REFERENCES rivers(id) ON DELETE CASCADE,
    mile NUMERIC(6,2) NOT NULL,
    description TEXT NOT NULL,
    raw_text TEXT,
    feature_type TEXT NOT NULL CHECK (feature_type IN (
        'access', 'spring', 'bridge', 'creek', 'campground', 'landmark', 'hazard', 'other'
    )),
    is_access_point BOOLEAN DEFAULT FALSE,
    is_campground BOOLEAN DEFAULT FALSE,
    has_spring BOOLEAN DEFAULT FALSE,
    has_bridge BOOLEAN DEFAULT FALSE,
    is_hazard BOOLEAN DEFAULT FALSE,
    side TEXT CHECK (side IN ('left', 'right')),
    highway TEXT,
    notes TEXT,
    -- PostGIS geometry (can be populated later via geocoding)
    location GEOGRAPHY(POINT, 4326),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    
    UNIQUE(river_id, mile, description)
);

-- Indexes for common queries
CREATE INDEX IF NOT EXISTS idx_mile_markers_river ON mile_markers(river_id);
CREATE INDEX IF NOT EXISTS idx_mile_markers_mile ON mile_markers(mile);
CREATE INDEX IF NOT EXISTS idx_mile_markers_feature_type ON mile_markers(feature_type);
CREATE INDEX IF NOT EXISTS idx_mile_markers_access ON mile_markers(is_access_point) WHERE is_access_point = TRUE;
CREATE INDEX IF NOT EXISTS idx_mile_markers_location ON mile_markers USING GIST(location);

-- Updated_at trigger function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Apply trigger to both tables
DROP TRIGGER IF EXISTS update_rivers_updated_at ON rivers;
CREATE TRIGGER update_rivers_updated_at
    BEFORE UPDATE ON rivers
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

DROP TRIGGER IF EXISTS update_mile_markers_updated_at ON mile_markers;
CREATE TRIGGER update_mile_markers_updated_at
    BEFORE UPDATE ON mile_markers
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Useful views

-- Access points only
CREATE OR REPLACE VIEW access_points AS
SELECT 
    mm.*,
    r.name as river_name,
    r.difficulty
FROM mile_markers mm
JOIN rivers r ON mm.river_id = r.id
WHERE mm.is_access_point = TRUE
ORDER BY r.name, mm.mile;

-- Float segments (distance between access points)
CREATE OR REPLACE VIEW float_segments AS
WITH access AS (
    SELECT 
        river_id,
        mile,
        description,
        LAG(mile) OVER (PARTITION BY river_id ORDER BY mile) as prev_mile,
        LAG(description) OVER (PARTITION BY river_id ORDER BY mile) as prev_description
    FROM mile_markers
    WHERE is_access_point = TRUE
)
SELECT 
    river_id,
    prev_description as put_in,
    prev_mile as put_in_mile,
    description as take_out,
    mile as take_out_mile,
    ROUND((mile - prev_mile)::numeric, 1) as distance_miles
FROM access
WHERE prev_mile IS NOT NULL
ORDER BY river_id, prev_mile;

-- RLS Policies (if using Supabase auth)
-- ALTER TABLE rivers ENABLE ROW LEVEL SECURITY;
-- ALTER TABLE mile_markers ENABLE ROW LEVEL SECURITY;
-- CREATE POLICY "Public rivers are viewable by everyone" ON rivers FOR SELECT USING (true);
-- CREATE POLICY "Public mile_markers are viewable by everyone" ON mile_markers FOR SELECT USING (true);
